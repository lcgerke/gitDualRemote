# Critical Analysis of GIT_DUAL_REMOTE_PLAN.md

## Assumptions
- **Valid**: The plan correctly treats the bare repo as the canonical source and GitHub as a backup/collaboration target, which aligns with the “Dual push” decision matrix and workflow descriptions (GIT_DUAL_REMOTE_PLAN.md:354-383). That separation keeps the fast pull/push path local while still giving collaborators a familiar public endpoint.
- **Valid but incomplete**: The assumption that GitHub automation via `gh` and Vault secrets can be centralized makes sense, but the description of authentication steps is still sketchy. The plan says it will “Authenticate `gh` CLI with SSH key” and “retrieve two secrets from Vault” (GIT_DUAL_REMOTE_PLAN.md:398-417) yet never shows the non-interactive `gh auth login --with-token` flow or how the SSH key is registered with GitHub, so the assumption that it can “just work” is optimistic.
- **Risky**: The tool assumes Vault is always reachable and has the exact per-repo secrets populated, then “fails fast” if anything is missing (GIT_DUAL_REMOTE_PLAN.md:455-518). Later sections still show a fallback to defaults when Vault reads fail (GIT_DUAL_REMOTE_PLAN.md:1102-1125), and the “Complete Vault Secret Structure” section says the global config is “optional” (GIT_DUAL_REMOTE_PLAN.md:1260-1270). This tension suggests the plan assumes operators will keep Vault pristine, but reality will include permission issues, transient network failures, or missing repo secrets, and there is no steadily documented recovery path.
- **Risky**: Relying on the custom state file at `~/.git-dual-remote/state.yaml` to signal “GitHub needs retry” (GIT_DUAL_REMOTE_PLAN.md:882-891) assumes the tool always has write permissions, that the file stays in sync when multiple clones exist, and that updates do not race with `git push` hooks; none of those failure modes is described.

## Gaps
- **Vault secret lifecycle**: The plan lists the exact secret locations (GIT_DUAL_REMOTE_PLAN.md:1260-1305) but never prescribes who creates them, how they rotate the SSH key and PAT, or how to handle a repo rename. Without documenting the provisioning UX (especially for per-repo secrets), adopters will lack guidance when a Vault entry is stale or absent.
- **Interplay between Vault config and CLI flags**: Flags such as `--github-user` and `--bare-remote` are presented in the command spec (GIT_DUAL_REMOTE_PLAN.md:434-453), yet the configuration strategy states “everything in Vault, fail fast if missing” (GIT_DUAL_REMOTE_PLAN.md:455-518). It is unclear whether the flags override Vault values, whether they are required when Vault entries exist, or how to bootstrap Vault values from the CLI. This ambiguity is a gap in the specification and invites inconsistent UX.
- **GitHub automation flow**: The plan promises to “auto-create GitHub repo if missing” (GIT_DUAL_REMOTE_PLAN.md:414-417) and handle PAT and SSH key retrieval (GIT_DUAL_REMOTE_PLAN.md:398-405), but it never details the steps to register the SSH key with GitHub, how to scope the PAT for automation (beyond “repo+workflow” in the security section, GIT_DUAL_REMOTE_PLAN.md:1734-1739), or how to handle `gh` CLI versions that cannot use SSH keys without interactive setup. That gap leaves a large portion of the “core setup” unverified.
- **Cross-platform concerns**: The plan claims cross-platform support (Windows, macOS, Linux) but all tooling references are Unix-centric (`/home/user`, `ssh`, `vault`, etc.) and the security section only talks about Unix permissions (GIT_DUAL_REMOTE_PLAN.md:1721-1750). There is no discussion of how `core.sshCommand`, `~/.ssh`, or Vault clients behave on Windows, so the cross-platform claim lacks substantiation.

## Technical Feasibility
- **Feasible but complex**: The stack (Go, Cobra, Vault, GitHub API, gh CLI, go-git, etc.) is capable of executing the required flow, and the plan even names dependencies (GIT_DUAL_REMOTE_PLAN.md:1591-1605). The biggest technical unknown is orchestrating `gh` CLI with SSH keys and PATs in a headless environment; once solved, the rest (adding remotes, setting dual push URLs, managing SSH config) follows established Git automation patterns.
- **Potential blocker**: The plan’s “dual-push verification” has the tool run `git ls-remote` on both remotes after every push and compares the raw output (GIT_DUAL_REMOTE_PLAN.md:862-878). If repositories grow large, these commands could be rate-limited, slow, or fail when the remotes are temporarily unreachable, which might prevent any push from succeeding if the verification is enforced strictly. The design needs thresholds or fallbacks so that transient `ls-remote` failures don’t block users indefinitely.

## Implementation Risks
- **Vault dependency**: Because the tool refuses to run unless Vault secrets exist (GIT_DUAL_REMOTE_PLAN.md:455-518), any Vault outage or RBAC change becomes a hard stop. The plan does not describe caching or offline modes for the Vault configuration, nor escalation paths when Vault itself is unreachable, yet Vault is now on the critical path for every command.
- **State file coupling**: Tracking `github_needs_retry` in `~/.git-dual-remote/state.yaml` (GIT_DUAL_REMOTE_PLAN.md:882-891) introduces a new shared artifact. If the file becomes corrupted or the repository is cloned elsewhere, the tool might lose its “retry” state, leading to divergence between remotes. There is no mechanism to rebuild the state from Git history or re-check statuses, so the state file is a single point of failure.
- **Git hook strategy and push options**: The “offline mode” relies on `git push --push-option=skip-github` and/or setting `GIT_DUAL_REMOTE_SKIP_GITHUB=1` (GIT_DUAL_REMOTE_PLAN.md:908-922). Git push options are not honored by all servers, and the environment variable leaks into the shell session; if the user forgets to unset it, every push skips GitHub unintentionally. There is no description of how the hook ensures the environment variable is cleared or how to detect when the skip flag was accidentally left set.
- **Telemetry of partial pushes**: The plan’s recovery flow records last errors and timestamps in state, then instructs the user to run `git-dual-remote sync --retry-github` (GIT_DUAL_REMOTE_PLAN.md:811-943). However, if the local repository has diverged further before the retry, the saved `commits_pending` count is stale, and the tool does not reconcile that mismatch before pushing again, risking force pushes or orphaned branches.

## Timeline Realism
- The “Development Phases” outline four well-scoped buckets (core setup, GitHub integration, polish, docs) with checkboxes (GIT_DUAL_REMOTE_PLAN.md:1608-1638), but there is no duration, no capacity estimate, and no dependency tracking. Similarly, the only explicit time commitment is “time-box the separate-vs.-combined decision to one week” (GIT_DUAL_REMOTE_PLAN.md:342-348). Without sprint lengths or a sequencing plan, stakeholders cannot judge whether the phases fit 1-2 weeks, 6 weeks, or several months, so the estimate is effectively “to be determined.”

## Concrete Improvements
1. **Document Vault onboarding**, including how to create the per-repo secrets, rotate keys, and recover when a key/PAT is missing. Tie those steps to the “Complete Vault Secret Structure” diagram (GIT_DUAL_REMOTE_PLAN.md:1258-1305) and explicitly state whether `git-dual-remote setup` can seed missing entries or must abort.
2. **Clarify flag vs. Vault precedence**: For each CLI flag (GIT_DUAL_REMOTE_PLAN.md:434-453), state whether it overrides the Vault-derived value and under what circumstances the flag is required versus optional; consider recording the resolved configuration in the state file so the user can inspect what actually ran.
3. **Expand the authentication flow**: Spell out the `gh` login commands, how the retrieved SSH key and PAT get registered with GitHub, and how the tool verifies those credentials before attempting repo creation (GIT_DUAL_REMOTE_PLAN.md:398-417). This will expose whether additional Vault secrets (e.g., GitHub App token) are needed and avoid surprises during implementation.
4. **Add error tolerance for verification**: Instead of running `ls-remote` on every push (GIT_DUAL_REMOTE_PLAN.md:862-878), introduce configurable retry limits or allow the verification to skip on offline installs, logging the warning but letting the push succeed so the bare repo isn’t blocked by temporary network glitches.
5. **Define timeline and owner**: For each development phase (GIT_DUAL_REMOTE_PLAN.md:1608-1638), attach an owner, a rough effort estimate (days or story points), and success criteria so it is clear when the plan is “done” and how long the complete build might take.
